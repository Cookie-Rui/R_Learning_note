####### R錦囊妙計：教學筆記 #######



# 第一章：開始使用R--------------------------------------

如何退出R軟體
一般方法：點擊右上角的「X」關閉
程式碼方法：q()



瀏覽輔助文件
help.start()



取得關於函數的資訊
顯示函數的輔助文件：help(函數名稱) or ?函數名稱
顯示函數的參數資訊：args(函數名稱)
顯示函數的使用範例：example(函數名稱)
以上方法僅限於函數所在之套件已被加載到工作區域，若尚未讀入套件，或不知道函數是屬於哪個套件的話，請使用下一個方法



若使用help()或?...無法顯示函數資訊的話，可以使用：help.search("函數名稱or關鍵字")
1. 已知函數屬於哪個套件，只是尚未加載套件：help(函數名稱, package="套件名稱")
2. 不知道函數屬於哪個套件：使用 help.search("函數名稱or關鍵字") 查詢所屬套件，再使用 help(函數名稱, package="套件名稱")



取得套件資訊
help(package="套件名稱")



尋找相關的函數與套件
到以下網站進行搜尋：
1. https://rseek.org/
2. https://cran.r-project.org/web/views/




# 第二章：基本觀念--------------------------------------

輸出顯示內容
直接輸入變數名稱或表達式

print()：格式化輸出
每次只能顯示一個物件，例如 print("aa", "bb") 就會發生錯誤
解決方式是用分號「;」，例如 print("aa") ; print("bb")

cat()：print()的替代方式之一
支援多個物件一次輸出，例如 cat("aa", "bb")
也支援顯示簡單向量，例如：
    number <- c(1, 2, 3, 4, 5)
    cat(number, ", Let's Go!!!")
但不支援複雜資料結構，例如list, matrix, data.table



設定變數
使用「<-」
x <- 3
y <- 4
z <- sqrt(x^2+y^2)

R是「動態型別語言」，代表它允許使用者改變特定變數的資料類型而不需做額外轉型
x <- 3
x <- c("a", "b", "c", "d", "e")

不建議使用「=」或「->」做為賦值方式，前者會跟邏輯判斷中的等號混淆，後者會使表達式變長，不易閱讀



列出變數
ls()：列出全部變數的名稱(回傳由字串組成的向量)
ls.str()：同上，但會顯示變數資訊，基本等同「ls()+str()」

若在變數名稱前面加上「.」，代表這是一個「隱藏變數」，ls()時不會顯示出來
例如：.hidden_var <- 5
若想要顯示出來，則可以加上參數：ls(all.names=TRUE)



刪除變數
rm()：刪除變數，支援多個變數一次刪除
rm(x)
rm(x, y, z)
rm(list=ls())：刪除所有變數(進行團隊協作時不得輕易寫入此程式碼，一來可能發生問題，二來這非常粗魯)



產生向量
使用 c(......)
單一向量中只能包含一種資料類型
c(1, 2, 3, 4, 5, 6, 7, 8, 9)
c("apple", "banana", "candy")
c(TRUE, FALSE, TRUE, TRUE)
v1 <- c(1,2,3)
v2 <- c(8,8,8)
v3 <- c("a", "b", "c")
c(v1, v2) # 1 2 3 8 8 8
c(v1, v3) # "1" "2" "3" "a" "b" "c"

向量內若存在不同資料型態，則轉型的優先順序是「文字 > 浮點數 > 整數」



計算基本統計量
mean()：平均數
median()：中位數
sd()：標準差
var()：變異數
cor()：相關係數
cov()：共變異數

若資料中含有NA，則會回傳NA表示計算無效，可以添加參數：na.rm=TRUE 來忽略NA值

若直接針對資料框進行計算，則會回傳每一個變項的統計量
cor() 跟 cov()會回傳相關係數矩陣/共變異數矩陣
var()的作用則是跟 cov() 一樣會回傳共變異數矩陣
median()裡面無法直接放資料框



產生數列/序列
冒號運算子(n:m)：產生等差數列
1:5 # 1 2 3 4 5
6:13 # 6 7 8 9 10 11 12 13
9:0 # 9 8 7 6 5 4 3 2 1 0

seq(from=x, to=y, by=z, lenth.out=w)：產生一個從 x 到 y，公差為 z，長度為 w 的數列
前兩個參數必須要有，其餘參數則可以省略
by跟length.out只能擇一撰寫，不然會出錯

rep()：建立重複序列
x <- c(1, 5, 9)
rep(x, times=3) # 1 5 9 1 5 9 1 5 9
rep(x, each=3) # 1 1 1 5 5 5 9 9 9
rep(x, times=3, each=3) # 1 1 1 5 5 5 9 9 9 1 1 1 5 5 5 9 9 9 1 1 1 5 5 5 9 9 9



邏輯判斷
== / != / > / < / >= / <=
v <- c(3, pi, 5)
w <- c(pi, pi, pi)
v == w # FALSE TRUE FALSE
v >= w # FALSE TRUE TRUE

若要比較一個向量跟一個數值，R會把數值擴展成跟向量長度一致的向量，然後再進行逐一比對
v <- c(3, pi, 5)
v == pi # FALSE TRUE FALSE
v != pi # TRUE FALSE TRUE

any()：若向量中的元素「至少」有一個TRUE，則回傳TRUE，反之則回傳FALSE
all()：若向量中的元素「所有」都是TRUE，則回傳TRUE，反之則回傳FALSE
any(v == pi) # TRUE
all(v == 0) # FALSE



選擇向量元素
grade <- c(94, 54, 88, 100, 77, 82, 65, 0, 94, 70)
1. grade[3]：取出grade向量中的第3個元素
2. grade[-3]：取出grade向量中第3個元素「以外」的元素
3. grade[1:4]：取出grade向量中的第1個到第4個元素 
4. grade[-(1:4)]：取出grade向量中第1個到第4個元素「以外」的元素
5. grade[c(1, 5, 9)]：取出grade向量中的第1、第5，第9個元素
6. grade[-c(1, 5, 9)]：取出grade向量中的第1、第5，第9個元素「以外」的元素
7. grade[grade > 80]：取出grade向量中的數值大於80的元素
8. grade[grade > 70 & grade < 90]：(AND運算)取出grade向量中的數值大於70「且」小於90的元素
9. grade[grade == 77]：取出grade向量中的數值等於77的元素
10. grade[grade %% 10 == 0]：取出grade向量中除以10後餘數等於0的元素
11. grade[grade %% 10 == 0 | grade > 70]：(OR運算)取出grade向量中除以10後餘數等於0「或」數值大於70的元素
12. grade[ !(grade %% 10 == 0) ]：(NOT運算)取出grade向量中除以10後餘數「不等於」0的元素
13. grade[grade %in% c(94, 88, 82)]：取出grade向量中「屬於、包含在」c(94, 88, 82)的元素(取交集)

實用功能：
grade[grade > median(grade)]：選擇所有大於中位數的元素
grade[(grade < quantile(grade, 0.05)) | (grade > quantile(grade, 0.95))]：選擇所有分布於下限與上限兩端5%範圍的元素
grade[abs((grade-mean(grade))/sd(grade)) > 2]：選擇所有在平均值正負2個標準差區間外的元素
grade[!is.na(grade) & !is.null(grade)]：選擇所有非NA也非NULL的元素

向量的names屬性：
y <- c(2, 4, 6, 8)
names(y) <- c("eric", "deniel", "andy", "amber")
y
# eric   deniel   andy   amber
#    2        4      6       8

y["eric"]
# eric
#    2
y["amber"]
# amber
#     8



向量運算
v <- c(10, 23, 4, 9, -7)
w <- c(1, 2, 3, 4, 5)
v+w # 11 25  7 13 -2
v-w #  9 21  1  5 -12
v*w # 10 46 12 36 -35
v/w # 10.000000  11.500000  1.333333  2.250000 -1.400000

w+2 # 3 4 5 6 7
w-2 # -1 0 1 2 3
w*2 # 2 4 6 8 10
w/2 # 0.5 1.0 1.5 2.0 2.5
2^w # 2 4 8 16 32

(v-mean(v))/sd(v) # 0.2027844  1.4010556 -0.3502639  0.1106096 -1.3641857
sin(v) # -0.5440211 -0.8462204 -0.7568025  0.4121185 -0.6569866



定義函數
函數名稱 <- function(parameter_1,...,parameter_n){
    expression
    ......
    ......
}

若表達式只有一行，則可以不用加上大括號{}
函數名稱 <- function(parameter_1,...,parameter_n) expression

若一個函數沒有定義名稱，則被稱作「匿名函數」，通常是用於單行表達式且一次性的簡單函數

例如同樣在lapply()中函數可以有兩種寫法：
cv <- function(x) sd(x)/mean(x)
lapply(list, cv) # 需要先定義好函數
-------------------------
lapply(list, function(x) sd(x)/mean(x)) # 不需要先定義好函數



二元運算子
任何介於兩個百分比符號(%...%)之間的內容會視為一個「二元運算子(binary operator)」

R已定義之二元運算子：
%%：取餘數 
%/%：整除(8 %/% 3 = 2)
%*%：矩陣乘積
%in%：若右側變量中包含左側變量時，回傳TRUE，反之則回傳FALSE

自定義二元運算子：
將百分比符號(%...%)之間的內容會視為二元運算子，並賦予它雙參數函數，即可定義一個新的二元運算子
"%+-%" <- function(x,margin) x+c(-1, 1)*margin # 計算x正負y的數值
"%+%" <- function(s1, s2) paste(s1, s2, seq="") # 將兩個字串以中間沒有空白的方式連接
100 %+-% (1.96*15) # 70.6 129.4
"Hello" %+% "World" # "HelloWorld"

二元運算子的運算優先層級十分高，甚至高於乘法與除法，因此需要特別注意
100 %+-% (1.96*15) 不等於 100 %+-% 1.96*15 # 前者是 70.6 129.4，後者是 1470.6 1529.4




# 第三章：導覽R軟體--------------------------------------