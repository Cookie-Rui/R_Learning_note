####### R錦囊妙計：教學筆記 #######



# 第一章：開始使用R-----------------------------------------------------

如何退出R軟體
一般方法：點擊右上角的「X」關閉
程式碼方法：q()



瀏覽輔助文件
help.start()



取得關於函數的資訊
顯示函數的輔助文件：help(函數名稱) or ?函數名稱
顯示函數的參數資訊：args(函數名稱)
顯示函數的使用範例：example(函數名稱)
以上方法僅限於函數所在之套件已被加載到工作區域，若尚未讀入套件，或不知道函數是屬於哪個套件的話，請使用下一個方法



若使用help()或?...無法顯示函數資訊的話，可以使用：help.search("函數名稱or關鍵字")
1. 已知函數屬於哪個套件，只是尚未加載套件：help(函數名稱, package="套件名稱")
2. 不知道函數屬於哪個套件：使用 help.search("函數名稱or關鍵字") 查詢所屬套件，再使用 help(函數名稱, package="套件名稱")



取得套件資訊
help(package="套件名稱")



尋找相關的函數與套件
到以下網站進行搜尋：
1. https://rseek.org/
2. https://cran.r-project.org/web/views/




# 第二章：基本觀念-----------------------------------------------------

輸出顯示內容
直接輸入變數名稱或表達式

print()：格式化輸出
每次只能顯示一個物件，例如 print("aa", "bb") 就會發生錯誤
解決方式是用分號「;」，例如 print("aa") ; print("bb")

cat()：print()的替代方式之一
支援多個物件一次輸出，例如 cat("aa", "bb")
也支援顯示簡單向量，例如：
    number <- c(1, 2, 3, 4, 5)
    cat(number, ", Let's Go!!!")
但不支援複雜資料結構，例如list, matrix, data.table



設定變數
使用「<-」
x <- 3
y <- 4
z <- sqrt(x^2+y^2)

R是「動態型別語言」，代表它允許使用者改變特定變數的資料類型而不需做額外轉型
x <- 3
x <- c("a", "b", "c", "d", "e")

不建議使用「=」或「->」做為賦值方式，前者會跟邏輯判斷中的等號混淆，後者會使表達式變長，不易閱讀



列出變數
ls()：列出全部變數的名稱(回傳由字串組成的向量)
ls.str()：同上，但會顯示變數資訊，基本等同「ls()+str()」

若在變數名稱前面加上「.」，代表這是一個「隱藏變數」，ls()時不會顯示出來
例如：.hidden_var <- 5
若想要顯示出來，則可以加上參數：ls(all.names=TRUE)



刪除變數
rm()：刪除變數，支援多個變數一次刪除
rm(x)
rm(x, y, z)
rm(list=ls())：刪除所有變數(進行團隊協作時不得輕易寫入此程式碼，一來可能發生問題，二來這非常粗魯)



產生向量
使用 c(......)
單一向量中只能包含一種資料類型
c(1, 2, 3, 4, 5, 6, 7, 8, 9)
c("apple", "banana", "candy")
c(TRUE, FALSE, TRUE, TRUE)
v1 <- c(1,2,3)
v2 <- c(8,8,8)
v3 <- c("a", "b", "c")
c(v1, v2) # 1 2 3 8 8 8
c(v1, v3) # "1" "2" "3" "a" "b" "c"

向量內若存在不同資料型態，則轉型的優先順序是「文字 > 浮點數 > 整數」



計算基本統計量
mean()：平均數
median()：中位數
sd()：標準差
var()：變異數
cor()：相關係數
cov()：共變異數

若資料中含有NA，則會回傳NA表示計算無效，可以添加參數：na.rm=TRUE 來忽略NA值

若直接針對資料框進行計算，則會回傳每一個變項的統計量
cor() 跟 cov()會回傳相關係數矩陣/共變異數矩陣
var()的作用則是跟 cov() 一樣會回傳共變異數矩陣
median()裡面無法直接放資料框



產生數列/序列
冒號運算子(n:m)：產生等差數列
1:5 # 1 2 3 4 5
6:13 # 6 7 8 9 10 11 12 13
9:0 # 9 8 7 6 5 4 3 2 1 0

seq(from=x, to=y, by=z, lenth.out=w)：產生一個從 x 到 y，公差為 z，長度為 w 的數列
前兩個參數必須要有，其餘參數則可以省略
by跟length.out只能擇一撰寫，不然會出錯

rep()：建立重複序列
x <- c(1, 5, 9)
rep(x, times=3) # 1 5 9 1 5 9 1 5 9
rep(x, each=3) # 1 1 1 5 5 5 9 9 9
rep(x, times=3, each=3) # 1 1 1 5 5 5 9 9 9 1 1 1 5 5 5 9 9 9 1 1 1 5 5 5 9 9 9



邏輯判斷
== / != / > / < / >= / <=
v <- c(3, pi, 5)
w <- c(pi, pi, pi)
v == w # FALSE TRUE FALSE
v >= w # FALSE TRUE TRUE

若要比較一個向量跟一個數值，R會把數值擴展成跟向量長度一致的向量，然後再進行逐一比對
v <- c(3, pi, 5)
v == pi # FALSE TRUE FALSE
v != pi # TRUE FALSE TRUE

any()：若向量中的元素「至少」有一個TRUE，則回傳TRUE，反之則回傳FALSE
all()：若向量中的元素「所有」都是TRUE，則回傳TRUE，反之則回傳FALSE
any(v == pi) # TRUE
all(v == 0) # FALSE



選擇向量元素
grade <- c(94, 54, 88, 100, 77, 82, 65, 0, 94, 70)
1. grade[3]：取出grade向量中的第3個元素
2. grade[-3]：取出grade向量中第3個元素「以外」的元素
3. grade[1:4]：取出grade向量中的第1個到第4個元素 
4. grade[-(1:4)]：取出grade向量中第1個到第4個元素「以外」的元素
5. grade[c(1, 5, 9)]：取出grade向量中的第1、第5，第9個元素
6. grade[-c(1, 5, 9)]：取出grade向量中的第1、第5，第9個元素「以外」的元素
7. grade[grade > 80]：取出grade向量中的數值大於80的元素
8. grade[grade > 70 & grade < 90]：(AND運算)取出grade向量中的數值大於70「且」小於90的元素
9. grade[grade == 77]：取出grade向量中的數值等於77的元素
10. grade[grade %% 10 == 0]：取出grade向量中除以10後餘數等於0的元素
11. grade[grade %% 10 == 0 | grade > 70]：(OR運算)取出grade向量中除以10後餘數等於0「或」數值大於70的元素
12. grade[ !(grade %% 10 == 0) ]：(NOT運算)取出grade向量中除以10後餘數「不等於」0的元素
13. grade[grade %in% c(94, 88, 82)]：取出grade向量中「屬於、包含在」c(94, 88, 82)的元素(取交集)

實用功能：
grade[grade > median(grade)]：選擇所有大於中位數的元素
grade[(grade < quantile(grade, 0.05)) | (grade > quantile(grade, 0.95))]：選擇所有分布於下限與上限兩端5%範圍的元素
grade[abs((grade-mean(grade))/sd(grade)) > 2]：選擇所有在平均值正負2個標準差區間外的元素
grade[!is.na(grade) & !is.null(grade)]：選擇所有非NA也非NULL的元素

向量的names屬性：
y <- c(2, 4, 6, 8)
names(y) <- c("eric", "deniel", "andy", "amber")
y
# eric   deniel   andy   amber
#    2        4      6       8

y["eric"]
# eric
#    2
y["amber"]
# amber
#     8



向量運算
v <- c(10, 23, 4, 9, -7)
w <- c(1, 2, 3, 4, 5)
v+w # 11 25  7 13 -2
v-w #  9 21  1  5 -12
v*w # 10 46 12 36 -35
v/w # 10.000000  11.500000  1.333333  2.250000 -1.400000

w+2 # 3 4 5 6 7
w-2 # -1 0 1 2 3
w*2 # 2 4 6 8 10
w/2 # 0.5 1.0 1.5 2.0 2.5
2^w # 2 4 8 16 32

(v-mean(v))/sd(v) # 0.2027844  1.4010556 -0.3502639  0.1106096 -1.3641857
sin(v) # -0.5440211 -0.8462204 -0.7568025  0.4121185 -0.6569866



定義函數
函數名稱 <- function(parameter_1,...,parameter_n){
    expression
    ......
    ......
}

若表達式只有一行，則可以不用加上大括號{}
函數名稱 <- function(parameter_1,...,parameter_n) expression

若一個函數沒有定義名稱，則被稱作「匿名函數」，通常是用於單行表達式且一次性的簡單函數

例如同樣在lapply()中函數可以有兩種寫法：
cv <- function(x) sd(x)/mean(x)
lapply(list, cv) # 需要先定義好函數
-------------------------
lapply(list, function(x) sd(x)/mean(x)) # 不需要先定義好函數



二元運算子
任何介於兩個百分比符號(%...%)之間的內容會視為一個「二元運算子(binary operator)」

R已定義之二元運算子：
%%：取餘數 
%/%：整除(8 %/% 3 = 2)
%*%：矩陣乘積
%in%：若右側變量中包含左側變量時，回傳TRUE，反之則回傳FALSE

自定義二元運算子：
百分比符號(%...%)之間的內容會視為二元運算子，並賦予它雙參數函數，即可定義一個新的二元運算子
"%+-%" <- function(x,margin) x+c(-1, 1)*margin # 計算x正負y的數值
"%+%" <- function(s1, s2) paste(s1, s2, seq="") # 將兩個字串以中間沒有空白的方式連接
100 %+-% (1.96*15) # 70.6 129.4
"Hello" %+% "World" # "HelloWorld"

二元運算子的運算優先層級十分高，甚至高於乘法與除法，因此需要特別注意
例如：100 %+-% (1.96*15) 不等於 100 %+-% 1.96*15 # 前者是 70.6 129.4，後者是 1470.6 1529.4




# 第三章：導覽R軟體-----------------------------------------------------

工作目錄設定與檢視
getwd()：檢視目前的工作目錄
setwd()：變更工作目錄
複製下來的目錄格式會長這樣："C:\Users\user\Documents"
若要透過 setwd() 來改變目錄，則要把目錄位置中的反斜線(\)改成正斜線(/)或者雙反斜線(\\)，如以下所示：
"C:/Users/user/Documents"
"C:\\Users\\user\\Documents"



儲存工作空間
save.image()：在不退出R的情況下儲存工作空間
在R執行的過程中會產生一個工作空間，用來儲存程式過程中產生的變數與函數(圖形不能被儲存)
這些內容會先被存放在主記憶體，等到要退出R的時候，系統會詢問是否要儲存工作空間的內容
若選擇儲存的話，工作空間會被存放在當前的工作目錄，副檔名為.RData的檔案中
save.image()可以讓使用者在不退出R的情況下儲存工作空間 



瀏覽歷史指令紀錄
history()：查看最近輸入的指令，預設是顯示25筆
history(100)：顯示25筆最近輸入的指令
history(Inf)：顯示所有最近輸入的指令



儲存前一筆指令執行的結果
若我們執行了一個很長的表達式，或是呼叫一個需要長時間來執行的函數，結果卻不小心忘了把執行結果存到一個變數裡面
此時我們可以使用 .Last.value 來獲得最近一次表達式的運算值或結果
aVeryLongRunningFunction()
[1] 147.123654 #忘了儲存!!
x <- .Last.value
x
[1] 147.123654



查看目前已載入的R套件
search()



載入套件與卸載套件

載入：
library(packagename) # 不需要雙引號，載入失敗時會回傳錯誤訊息
require(packagename) # 作用和library()一樣，只是require()會在成功載入套件後回傳TRUE，且載入失敗時只會回傳警告訊息

卸載：
detach(package:套件名稱) # 要注意格式



存取內建資料集
R本身有附上許多內建資料集，透過 data() 可以查看內建資料集列表
而因為內建資料集所屬的套件(datasets)會被R所預先載入，因此我們可以直接存取這些資料集，例如：
head(pressure)
help(pressure)

若要使用其他套件中的資料集的話，則有兩種方法；
1. 未載入套件：data(資料集名稱, package="套件名稱")
2. 已載入套件：如同內建資料集，直接存取即可

也可以使用 data(package="套件名稱") 來查看某套件中的資料集列表



檢視已安裝套件的列表
library()：使用不加任何參數的 library() 來查看套件列表
installed.packages()：同上，只是會顯示更多資訊，且會以矩陣方式呈現資料
installed.packages()[ ,c("Package", "Version")]：呼叫 installed.packages() ，並擷取Package跟Version兩個變項



安裝套件
install.packages("套件名稱")



執行腳本
若今天有一個.R檔案叫做"test.R"，裡面有一大串的程式碼，然後我們想要在R中執行全部程式碼
則可以使用 source() 來執行程式碼
source("test.R")
source("test.R", echo=TRUE) # 執行某段程式碼之前先顯示該段程式碼的內容



查看R的起始目錄
Sys.getenv("R_HOME")




# 第四章：輸入與輸出-----------------------------------------------------

使用鍵盤輸入資料
c()：建立向量
data.frame()：建立資料框

使用範例：
name <- c("eric", "joyce", "kelly")
age <- c(19, 20, 17)
grade <- c(90.5, 99, 81.4)
result <- data.frame(Name = name, Age = age, Grade = grade, sex = c(1, 2, 2))
#    Name Age Grade sex
# 1  eric  19  90.5   1
# 2 joyce  20  99.0   2
# 3 kelly  17  81.4   2

也可以先建立一個空資料框，然後使用 edit() 來開啟編輯器進行手動填入或修改
paper <- data.frame()
temp <- edit(paper) #開啟編輯器
paper <- temp

因為在編輯器所做的更動無法復原，因此建議先將編輯後的結果存到temp中，確認無誤過後再指定回原變數當中
若你對你的修改十分有信心的話，也可以使用 fix() 來啟動編輯器，並將結果自動覆蓋回原變數中



